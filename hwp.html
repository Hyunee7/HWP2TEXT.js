<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>hwp 보기</title>
  <style>
    body {background-color:#181818; color:#bbbbbb;}
    pre {
        white-space: break-spaces;
     /* white-space: pre-wrap; */
    }
  </style>
  <script src="kssmcode.js?v=<?=filemtime('kssmcode.js')?>"></script>
  <!-- <script src="jszip.min.js?v=<?=filemtime('jszip.min.js')?>"></script> -->
  <!-- <script src="jszip.js?v=<?=filemtime('jszip.js')?>"></script> -->
  <script src="pako.js?v=<?=filemtime('pako.js')?>"></script>
  <script>
    Number.prototype.format = function(){return new String(this).replace(/\B(?<!\.\d*)(?=(\d{3})+(?!\d))/g, ",")}

    var params = URLSearchParams && new URLSearchParams(document.location.search.substring(1));
    var url = params && params.get("url") && decodeURIComponent(params.get("url"));

    var DEBUG = false;

    function HWP(buffer){
         getByte = new GetByte(buffer);
         GetByte.debug=DEBUG;
        //HWP.getByte = getByte;
        //var charbuf = [];
        //var pos=0;

        function HeaderString(){ // 30 Byte -- 파일인식정보
            return {
                text    : getByte(19)
               ,version : getByte( 5)
               ,eof     : getByte( 1, 'int8') // 26 0x1A EOF
               ,no1     : getByte( 1, 'int8') // 1
               ,no2     : getByte( 1, 'int8') // 2
               ,no3     : getByte( 1, 'int8') // 3
               ,no4     : getByte( 1, 'int8') // 4
               ,no5     : getByte( 1, 'int8') // 5
            }
        }

        var 용지종류=['사용자 정의','프린트 80','프린트 132','A4','레터','B5','B4','리갈','A3'];
        HWP.용지종류 = 용지종류;
        var HWP1X = false;
        HWP.HWP1X = HWP1X;
        function FileHeader(hs){ // 128 Byte
            HWP1X = hs.version.charAt(0)=='1';
            HWP.HWP1X = HWP1X;
            return {
                 커서줄     : getByte( 2, 'int16') // 문서를 저장할 당시 커서가 위치한 문단 번호
                ,커서칸     : getByte( 2, 'int16') // 문서를 저장할 당시 커서가 위치한 문단 칸
                //,용지종류   : getByte( 1, 'int8' ) // 용지종류
                ,용지종류   : 용지종류[getByte( 1, 'int8' )] // 용지종류
                ,용지방향   : getByte( 1, 'int8' ) // 0:보통 1:넓게
                ,용지길이   : getByte( 2, 'int16') // 1/1800인치
                ,용지너비   : getByte( 2, 'int16') // 1/1800인치
                ,위쪽여백   : getByte( 2, 'int16') // 1/1800인치
                ,아래쪽여백 : getByte( 2, 'int16') // 1/1800인치
                ,왼쪽여백   : getByte( 2, 'int16') // 1/1800인치
                ,오른쪽여백 : getByte( 2, 'int16') // 1/1800인치
                ,머리말길이 : getByte( 2, 'int16') // 1/1800인치
                ,꼬리말길이 : getByte( 2, 'int16') // 1/1800인치
                ,제본여백   : getByte( 2, 'int16') // 1/1800인치
                ,문서보호   : getByte( 4, 'int32') // 0:일반문서 1:보호된 문서 (편집불가)
                ,예약       : getByte( 2, 'int16') // 1:HWP 외부에서 만들어진 문서(컨버터가 만든문서) bit  처리, 외부문서의 경우 realign.
                ,쪽번호연결  : getByte( 1, 'int8' ) // 1 = 연결, 0 = 새로 시작 (연결 인쇄에서 사용됨)
                ,각주번호연결: getByte( 1, 'int8' ) // 1 = 연결, 0 = 새로 시작 (연결 인쇄에서 사용됨)
                ,연결인쇄파일 : getByte( HWP1X?35:40 ) // 연결 인쇄할 파일의 이름
//                ,연결인쇄파일 : getByte(  40) // 연결 인쇄할 파일의 이름
                ,덧붙이는말   : getByte(  24) // 문서 파일에 대한 부가설명
//                ,tmp31 : getByte(  1, 'int8')  // 121 번째 - 암호화여부 1
//                ,tmp32 : getByte(  1, 'int8')  // 122 번째 - 암호화여부 2
                ,암호여부 : getByte( 2, 'int16') // 0:보통 파일, 이외:암호 걸린 파일
                ,시작페이지번호 : getByte( 2, 'int16')
                ,각주옵션:{각주시작번호:getByte( 2, 'int16')
                          ,예약        :getByte( 2, 'int16') // (각주개수)
                          ,분리선간격  :getByte( 2, 'int16') // 각주 분리선과 본문 사이의 간격
                          ,본문간격    :getByte( 2, 'int16') // 각주와 본문 사이의 간격
                          ,각주간격    :getByte( 2, 'int16') // 각주와 각주 사이의 간격
                          ,괄호        :getByte( 1, 'int8' ) // ')' = 각주 번호에 ')'를 붙임, 0=안 붙임
                          ,분리선너비  :getByte( 1, 'int8' )}// 각주 분리선 너비. 0=5cm, 1=본문의 1/3, 2=단너비, 3=없음
                ,테두리간격:{왼쪽  :getByte( 2, 'int16')  // 쪽 테두리와 본문 간격 (왼쪽,오른쪽,위,아래)
                            ,오른쪽:getByte( 2, 'int16')
                            ,위    :getByte( 2, 'int16')
                            ,아래  :getByte( 2, 'int16')}
                ,테두리종류 : getByte( 2, 'int16') //  쪽 테두리 선의 종류.  0 = 없음, 이외 = 종류
                ,빈줄감춤   : getByte( 1, 'int8' ) // 0 이외 = on
                ,틀옮김     : getByte( 1, 'int8' ) // 0 이외 = on
                ,압축       : getByte( 1, 'int8' ) // 0 = 압축되지 않은 파일, 이외 = 압축된 파일
                ,subRevision: getByte( 1, 'int8' ) // 언제나 1 (0은 글3.0에서 만든파일)
                ,tmp1 : HWP1X?getByte(  1, 'int8'):''  // v1.x 에만 사용함.
                ,tmp2 : HWP1X?getByte(  1, 'int8'):''  // v1.x 에만 사용함.
                ,tmp3 : HWP1X?getByte(  1, 'int8'):''  // v1.x 에만 사용함.
                ,tmp4 : HWP1X?getByte(  1, 'int8'):''  // v1.x 에만 사용함.
                ,tmp5 : HWP1X?getByte(  1, 'int8'):''  // v1.x 에만 사용함.
                ,정보블록길이:getByte( 2, 'int16') // 정보 블록의 길이 (바이트 단위)

            }
        }

        //console.log(`[${getByte(24)}]`)
        //console.log(`[${JSON.stringify(HeaderString())}]`)
        var headerString = HeaderString();
        HWP.headerString = headerString;
        //if(DEBUG)
            console.log(headerString)
        if(headerString.text != 'HWP Document File V') return 'HWP V1.2, V1.5, V3.0 문서가 아님';
        var fileHeader = FileHeader(headerString);
        HWP.fileHeader = fileHeader;
        //if(DEBUG)
            console.log('fileHeader', fileHeader)
        if(DEBUG) console.log(GetByte.pos)


//        if(headerString.version.indexOf('1.2')==-1
//           && headerString.version.indexOf('1.5')==-1) return 'HWP Document File V1.2, V1.5 문서만 지원함.\n ---> HWP Document File V' + headerString.version;


        function HWP1XRead(){  // HWP V1.x 용 문서 읽기
            function TextHeader(){ // 20 Byte 
                return {
                    num1 : getByte( 1, 'int8') 
                   ,num2 : getByte( 1, 'int8') 
                   ,info : getByte(18) 
                }
            } 

            function AttrHeader(){ // 3 Byte
                return {
                    num  : getByte(1, 'int8' )
                   ,attr : getByte(2, 'int16')
                }
            }
    //        var MAXHWPLINE = 100;
            var MAXHWPLINE = 1000;
            var max = 0;
            var str = '';
            while (max < MAXHWPLINE - 1) {
//            while (max < 6) { // DEBUG용
                //console.log('max',max)
                var textHeader = TextHeader();
                //console.log('textHeader',textHeader)
                var charnum = textHeader.num1 * 256 + textHeader.num2;
                while (charnum == 0) {
                    var textHeader = TextHeader();
                    //console.log('textHeader',textHeader)
                    if(textHeader.num2 == 26) return; // 파일끝(EOF:26) 이면 강제종료
                    charnum = textHeader.num1 * 256 + textHeader.num2;
                    //console.log('charnum',charnum)
                }
                var attrnum = 0;
                while (charnum > attrnum) {
                    var attrHeader = AttrHeader ();
                    //console.log('attrHeader',attrHeader)
                    attrnum += attrHeader.num;
                    //console.log('charnum',charnum)
                }
                var empty = getByte(1, 'int8' ); // 0x00
                //console.log('empty',empty)

                for (var i=pos=0;i < charnum;i++) {
                    var ch = getByte('hchar');
                    //if(GetByte.isErr) console.log(i )
                    str+=ch;
                    //pos++;
                    //if (pos > 253) break;
                }
//                console.log(str)
/**/
                max++;
            }
            return str;
        }

//        GetByte.isHwp = true; // HWPChar 적용시작
        if(DEBUG) console.log('HWP1X',HWP1X)
        if(HWP1X) return HWP1XRead();  // 1.x 용문서이면 읽어서 반환함 이후 취소

        function 문서요약정보(){ // 1008 Byte
            return {
                 제목   : getByte(56*2) // HWPChar 형식으로 읽음 2바이트 문자가 1개의 문자임.
                ,주제   : getByte(56*2)
                ,지은이 : getByte(56*2)
                ,날짜   : getByte(56*2)
                ,키워드 : [getByte(56*2),getByte(56*2)]
                ,기타   : [getByte(56*2),getByte(56*2),getByte(56*2)]
            };
        }

        /* V3.X 문서의 경우 */
        var 문서요약;
//        if(headerString.version.indexOf('3.')>-1){ // 3.0 문서인경우
        GetByte.isHwp = true; // HWPChar 적용시작
            문서요약 = 문서요약정보();
        GetByte.isHwp = false; // HWPChar 적용해제
            HWP.문서요약 = 문서요약;
            //if(DEBUG) 
                console.log('문서요약',문서요약);
//            console.log(GetByte.pos)
//        }
        if(DEBUG) console.log(GetByte.pos)


        function 정보블럭정보(){ // 가변
            var 정보={ID:0, 길이:0, 내용:[]};
            정보.ID = getByte(2,'int16');
            정보.길이 = getByte(2,'int16');
            for(i=0; i<정보.길이; i++) 정보.내용.push( getByte(1, 'int8') );
            //정보.내용=getByte(정보.길이);
            return 정보;
            /*
            return {
                ID  :getByte(2,'int16')
               ,길이:getByte(2,'int16')
               ,내용:''
           }
           */
        }

        if(DEBUG) console.log('fileHeader.정보블록길이', fileHeader.정보블록길이)
        if(fileHeader.정보블록길이){
            GetByte.isHwp=false; // HWPChar 해제
            var 정보블럭=정보블럭정보();
            HWP.정보블럭 = 정보블럭;
            //정보블럭.내용=getByte(28687);
            //정보블럭.내용=GetByte.uInt8Array.slice(GetByte.pos, GetByte.pos+정보블럭.길이); // 정보블럭 내용은 다음에
            //if(DEBUG)
                console.log('정보블럭',정보블럭);
            if(DEBUG) console.log('pos', GetByte.pos, GetByte.uInt8Array.length)
        }

        //getByte(GetByte.pos+정보블럭.길이, 'pos'); // 내용만큼 포인트 이동
        //console.log('pos', GetByte.pos, GetByte.uInt8Array.length)

        if(DEBUG) console.log('fileHeader.압축', fileHeader.압축)

        if(fileHeader.압축){
            //zip = new JSZip();
            var data = GetByte.uInt8Array.slice(GetByte.pos, GetByte.uInt8Array.length);
            //contents = zip.loadAsync(data); // decodeFileName 은 한글 제목을 decode 하기위해서이다.

            content = pako.inflate(data, { windowBits: -15 }); //압축되어있어 풀어줘야함
            getByte = GetByte(content); // 버퍼 재설정
            
        }

        function 글꼴이름정보(){
            GetByte.isHwp=false; // HWPChar 해제
            //GetByte.isHwp=true; // HWPChar 해제
            var 정보 = {한글:{nfonts:0,fontnames:[]}
                       ,영문:{nfonts:0,fontnames:[]}
                       ,한자:{nfonts:0,fontnames:[]}
                       ,일어:{nfonts:0,fontnames:[]}
                       ,기타:{nfonts:0,fontnames:[]}
                       ,기호:{nfonts:0,fontnames:[]}
                       ,사용자:{nfonts:0,fontnames:[]}}
            정보.한글.nfonts = getByte(2, 'int16');
            for(var i=0; i<정보.한글.nfonts; i++) 정보.한글.fontnames.push( getByte(40) );
            정보.영문.nfonts = getByte(2, 'int16');
            for(var i=0; i<정보.영문.nfonts; i++) 정보.영문.fontnames.push( getByte(40) );
            정보.한자.nfonts = getByte(2, 'int16');
            for(var i=0; i<정보.한자.nfonts; i++) 정보.한자.fontnames.push( getByte(40) );
            정보.일어.nfonts = getByte(2, 'int16');
            for(var i=0; i<정보.일어.nfonts; i++) 정보.일어.fontnames.push( getByte(40) );
            정보.기타.nfonts = getByte(2, 'int16');
            for(var i=0; i<정보.기타.nfonts; i++) 정보.기타.fontnames.push( getByte(40) );
            정보.기호.nfonts = getByte(2, 'int16');
            for(var i=0; i<정보.기호.nfonts; i++) 정보.기호.fontnames.push( getByte(40) );
            정보.사용자.nfonts = getByte(2, 'int16');
            for(var i=0; i<정보.사용자.nfonts; i++) 정보.사용자.fontnames.push( getByte(40) );
            return 정보;
        }
        var 글꼴이름 = 글꼴이름정보();
        if(DEBUG) console.log('글꼴이름',글꼴이름);
        HWP.글꼴이름 = 글꼴이름;
        if(DEBUG) console.log('pos', GetByte.pos, GetByte.uInt8Array.length)

            function 문단모양자료구조(){ // 187 Byte
                function 탭설정(){ // 4 Byte
                    return {
                         종류      :getByte( 'byte')  // 0 ～ 3 (왼쪽, 오른쪽, 가운데, 소수점 탭)
                        ,점끌기여부:getByte( 'byte')
                        ,탭위치    :getByte('hunit')
                    }
                }
                function 단정의(){ // 8 Byte
                    return {
                         단수    :getByte( 'byte')
                        ,단구분선:getByte( 'byte')// 0-4. {조판,다단,단구분선, 메뉴 순서 (도스 버전 기준)}
                        ,단간격  :getByte('hunit')
                        ,예약    :[getByte('byte'),getByte('byte')
                                  ,getByte('byte'),getByte('byte')]
                    }
                }
                var info = {
                     왼쪽여백    :getByte( 'hunit')
                    ,오른쪽여백  :getByte( 'hunit')
                    ,들여쓰기    :getByte('shunit')
                    ,줄간격      :getByte( 'hunit') // MSB가 1이면 절대 간격, 이외는 퍼센트 단위
                    ,문단아래간격:getByte( 'hunit')
                    ,낱말간격    :getByte(  'byte') // 퍼센트 단위
                    ,정렬방식    :getByte(  'byte') // 0 - 7, 도스 버전의 ‘문단모양-정렬방식’ 순서.
                    ,탭설정      :[] // 최대 40개까지의 {탭 설정} 정보
                    ,단정의      :단정의() // 다단에 대한 정보
                    ,음영비율    :getByte(  'byte') // 문단 테두리 음영 비율, 퍼센트 단위
                    ,문단테두리  :getByte(  'byte') // 0 = 문단 테두리 없음, 1 = 문단 테두리 있음
                    ,선연결      :getByte(  'byte') // 0 = 위/아래 문단과 테두리 선 연결하지 않음
                                                    // 1 = 위/아래 문단과 테두리 선 연결
                    ,문단위간견  :getByte( 'hunit')
                    ,예약        :[getByte('byte'),getByte('byte')]
                }
                for(var i=0; i<40; i++) info.탭설정.push( 탭설정() );
                return info;
            }


        function 스타일정보(){
            var info = {개수:0, 정보:[]}
            info.개수 = getByte(2,'int16');
            for(var i=0; i<info.개수; i++) {
                info.정보.push({이름:getByte(20)
                               ,글자모양:글자모양자료구조()
//                               ,문단모양:getByte(187)});
                               ,문단모양:문단모양자료구조()});
            }

            return info;
        }
        var 스타일 = 스타일정보();
        HWP.스타일 = 스타일;
        if(DEBUG) console.log('스타일', 스타일);
        if(DEBUG) console.log('pos', GetByte.pos, GetByte.uInt8Array.length)

        function getByteArray(type, cnt){
            var tmp = [];
            for(var i=0; i<cnt; i++){
                tmp.push( getByte(type) );
                if(GetByte.pos>=GetByte.uInt8Array.length) break;
            }
            return tmp;
        }

        function 글자모양자료구조(){
            return {
                 크기    :getByte('hunit') // 글자의 크기
                ,글꼴    :getByteArray('byte',7) // 각 언어별 글꼴 인덱스(표 34 참조)
                ,글꼴    :getByteArray('byte',7) // 각 언어별 장평 비율, 50% ～ 200%(표 34 참조)
                ,자간    :getByteArray('byte',7) // 각 언어별 자간 비율, -50% ～ 50%(표 34 참조)
                ,음영색  :getByte('byte') // 0 ～ 7, 메뉴 순서 대로 *
                ,글자색  :getByte('byte') // 0 ～ 7, 메뉴 순서 대로 *
                ,음영비율:getByte('byte') // 0% ～ 100%
                ,속성    :getByte('byte') // bit 0 = 이탤릭
                                          // bit 1 = 진하게
                                          // bit 2 = 밑줄
                                          // bit 3 = 외곽선
                                          // bit 4 = 그림자
                                          // bit 5 = 위첨자
                                          // bit 6 = 아래첨자
                                          // bit 7 = 글꼴에 어울리는 빈 칸
                ,예약    :getByteArray('byte',4)
            }
        }

        function 문단정보(){  // 43 또는 230 바이트
            info = {
                 앞문단모양    :getByte('byte') // 0 = 새 문단 모양이 저장됨
                                                // 이외 = 앞 문단 모양을 따라감
                ,글자수        :getByte('word') // 0 = 빈 문단 (문단 리스트의 끝)
                                                // 이외 = 문단 내용의 글자 수 (hchar 단위)
                ,줄수          :getByte('word') // 문단의 줄 수
                ,글자모양포함  :getByte('byte') // 0 = 모든 글자가 대표 글자 모양을 따라감
                                                // 이외 = 각 글자에 대한 모양이 별도로 저장됨
                ,기타플래그    :getByte('byte') // bit 0 = 단 나눔
                                                // bit 1 = 페이지 나눔
                                                // bit 2 = 조판 나눔
                                                // bit 3 = 블록 보호 시작
                                                // bit 4 = 블록 보호 중간
                                                // bit 5 = 블록 보호 끝
                                                // bit 6 = 외톨이줄 보호
                                                // bit 7 = 예약
                ,특수문자플래그:getByte('dword') // 각 비트가 0-31 사이의 특수 문자 존재 여부를 표현
                ,스타일        :getByte('byte') // 문단의 스타일 인덱스
              //,대표글자모양  :null // ‘글자 모양 포함*’이 0일 때 사용될 글자 모양
                ,대표글자모양  :글자모양자료구조() // ‘글자 모양 포함*’이 0일 때 사용될 글자 모양
                ,문단모양      :null // ‘앞 문단 모양*’이 0일 때만 저장됨
            }
            //if(info.글자모양포함==0) info.대표글자모양 = 글자모양자료구조()
            if(info.특수문자플래그){
                for(var i=0; i<32; i++){
                    if((info.특수문자플래그 >> i) == 1){
                        info.특수문자플래그번호 = i;
                        break;
                    }
                }
            }
            if(info.앞문단모양==0 && info.글자수) info.문단모양     = 문단모양자료구조()
            return info;
        }

        function 줄정보(){
            return {
                 줄의시작위치 :getByte( 'word') // 문단 내용에서 줄이 시작하는 위치 (hchar 단위 오프셋)
                ,공백보정값   :getByte('hunit') // 보정을 위해 공백 문자의 폭에 더해줄 값
                ,줄의높이     :getByte('hunit') // 줄에서 가장 큰 글자의 높이
                ,예약         :getByteArray('byte',6)
                ,단_페이지구분:getByte( 'word') // 이 줄이 단/페이지의 경계인지 여부
                                                // bit 0 = 페이지 경계
                                                // bit 1 = 단 경계
                                                // bit 2-14 = 예약
                                                // bit 15 = 1일 때만 단/페이지 구분 정보가 유효하다.
            }
        }
        function 글자모양정보(글자수) {
            var info = [];
            for(var i=0; i<글자수; i++){
                var tmp = {flag:null,글자모양:null}
                tmp.flag = getByte('byte');
                if(tmp.flag!=1) {
                    tmp.글자모양 = 글자모양자료구조() ;
                }
                info.push( tmp );
            }
            return info;
        }

        function 추가정보(){
            var info = {ID:0,길이:0,내용:[]};
            info.ID   = getByte('dword');
            info.길이 = getByte('dword');
            info.내용 = getByteArray('byte',info.길이);
            return info;
        }

        function 셀정보(){ // 27 Byte
            var 선종류값=['0:투명', '1:실선', '2:굵은 실선', '3:점선', '4:2중 실선'];

            return {
                 줄:getByte('byte') // 내장 시트 기능을 위한 줄, 칸 일련 번호 (0에서 시작)
                ,칸:getByte('byte') // 내장 시트 기능을 위한 줄, 칸 일련 번호 (0에서 시작)
                ,셀의색깔:getByte('word')
                ,셀의위치:{가로:getByte('hunit'),세로:getByte('hunit')}
                ,셀의크기:{가로:getByte('hunit'),세로:getByte('hunit')}
                ,텍스트높이:getByte('hunit') // 셀 안에 있는 텍스트 내용의 높이
                ,셀높이:getByte('hunit') // 사용자가 지정한 셀의 높이.
                                         // 실제 셀의 세로 크기는 '텍스트 높이'와 '셀 높이'중에서 
                                         // 큰 쪽으로 선택된다.
                ,예약:getByteArray('byte',2)
                ,상수:getByte('byte') // 늘 1 이다
                ,가운데로:getByte('byte') // 셀 안의 글을 세로로 가운데로 오게 할지 여부
                //,선종류:getByteArray('byte',4) // 셀의 선 종류 (왼쪽, 오른쪽, 위, 아래)
                //                               // 선 종류: 0 = 없음, 1-4 = 메뉴 순서대로
                //                               // 0 : 투명
                //                               // 1 : 실선
                //                               // 2 : 굵은 실선
                //                               // 3 : 점선
                //                               // 4 : 2중 실선
                ,선종류:{왼쪽:선종류값[getByte('byte')], 오른쪽:선종류값[getByte('byte')]
                        ,위:선종류값[getByte('byte')], 아래:선종류값[getByte('byte')]}
                ,음영비율:getByte('byte') // 0% - 100%
                ,대각선:getByte('byte') // bit 0,1 : 대각선 방향 (0=없음, 1=\, 2=/, 3 = X )
                                        // bit 2 : 한 줄로 입력 Flag - 자동align되지 않음
                                        // bit 3 : reserved
                                        // bit 4 : 대각선 merge된 cell인가
                                        // bit 5 : 대각선 merge된 cell일때 0=가로, 1=세로
                                        // bit 6,7 : reserved
                ,보호:getByte('byte') // 보호를 위해 셀로 들어갈 수 없도록 할지 여부
            }
        }

        function 틀헤더정보(){ // 
            return {
                 헤더길이:getByte('dword') // 자신을 뺀 헤더의 길이, 현재는 24
                ,zorder:getByte('dword') // 틀의 zorder 값. 첫 비트가 서 있으면 글 뒤.
                ,개체수:getByte('dword') // 묶여 있는 개체의 개수.
                ,차지영역:getByteArray('shunit32',4) // 선 두께 등을 고려하여 개체가 차지하는 영역을 x, y, 
                                                     // xsize, ysize 순서로 나타냄. 좌표는 틀의 원점부터 
                                                     // 상대적인 값.
            }
        }
        function 하이퍼텍스트정보(){ // 4 + 617 x n
            return {
                 길이:getByte('dword') // 617 x n = 하이퍼텍스트 정보 길이
                ,건널뛸파일이름:getByteArray('hchar',256) // 현재 파일의 책갈피라면 "\0"
                ,건너뛀책갈피:getByteArray('hchar',16) // ‘[문서의 처음]’은 실제 존재하지는 
                                                       // 않지만, 사용되는 책갈피 이름
                ,매크로:getByteArray('byte',325) // 도스용에서 실행할 매크로
                ,종류:getByte('byte') // 0,1 = 글, 2 = HTML
                ,예약:getByteArray('byte',3) // 
            }
        }
        function 그리기개체기본속성(){ // 44 Byte
            return {
                 선모양:{선의스타일:getByte('dword')
                        ,끝부분화살표스타일:getByte('dword')
                        ,시작부분화살표스타일:getByte('dword')}
                ,선색깔:getByte('dword') // RGB 값
                ,선굵기:getByte('hunit32') // 선의 굵기
                ,면색깔:getByte('dword') // RGB 값
                ,무늬종류:getByte('dword')  // bit 0-23  = 종류
                                            // bit 24-31 = bit 24: solid(0)/hatched(1)
                                            // bit 25: bitmap pattern(이미지 fill)
                ,무늬색깔:getByte('dword') // RGB 값
                ,글상자여백:{가로:getByte('hunit32') // 글상자 가로, 세로 여백.
                            ,세로:getByte('hunit32')}
                ,기타옵션:getByte('dword') // bit 0 = 둥근 모서리
                                           // bit 1 = 부채꼴 테두리
                                           // bit 2 = 반원 모서리
                                           // bit 3 = 개체의 크기에 맞춰 비트맵 크기 조절
                                           // bit 4 = 가운데 정렬 (그리기 글상자)
                                           // bit 5 = 다각형이 닫혀졌는 지의 여부
                                           // bit 6 - 15 = 예약
                                           // bit 16 = 그라데이션 속성 존재 여부
                                           // bit 17 = 회전 속성 존재 여부
                                           // bit 18 = 비트맵 패턴 속성 존재 여부
                                           // bit 19 = 그리기를 글상자로 만들 것인지의 여부
                                           // bit 20 = 워터마크 속성 존재 여부
                                           // bit 21 - 31 = 예약
            }
        }
        function 그리기개체회전속성(){ // 32 Byte
            return {
                 x좌표:getByte('hunit32')
                ,y좌표:getByte('hunit32')
                ,평행사변형:getByte('hunit32',6) // 평행 사변형을 표현하는 세 개의 좌표를 각각 x, y 순으로 
                                                 // 저장한다. 사각형을 회전시키고 나서 사이즈를 바꾸면 
                                                 // 평행 사변행이 된다.
            }
        }
        function 그리기개체그라데이션속성(){ // 28 Byte
            return {
                 시작색깔:getByte('dword') // RGB 값.
                ,끝색깔:getByte('dword') // RGB 값.
                ,그라데이션종류:getByte('dword') // 선형, 원형, 원뿔형, 사각형 (1 - 4)
                ,회전각도:getByte('dword') // 중심축과 이루는 각도 (0 - 360)
                ,가로중심:getByte('dword') // 가로 중심 (0 - 100%)
                ,세로중심:getByte('dword') // 세로 중심 (0 - 100%)
                ,단계:getByte('dword') // 밀도 (0 - 100)
            }
        }
        function 그리기개체공통헤더정보(){ // 최대 430 Byte
            var info = {
                 헤더길이:getByte('dword') // 자신을 뺀 공통 헤더의 길이. 속성에 따라 가변.
                ,개체종류:['0 = 컨테이너'
                          ,'1 = 선'
                          ,'2 = 사각형'
                          ,'3 = 타원'
                          ,'4 = 호'
                          ,'5 = 다각형'
                          ,'6 = 글상자'
                          ,'7 = 곡선'
                          ,'8 = 변형된 타원 (회전되거나 호로 편집된 타원)'
                          ,'9 = 변형된 호 (회전된 호)'
                          ,'10 = 선을 그릴 수 있도록 확장된 곡선'][getByte('word')]
                ,연결정보:[0
                          ,'bit 0 = sibling이 존재하는지 여부'
                          ,'bit 1 = child가 존재하는지 여부'][getByte('word')]
                ,상대위치:{x:getByte('hunit32'),y:getByte('hunit32')} // 개체가 속한 그룹의 원점부터 개체 위치 x, y.
                ,개체크기:{가로:getByte('hunit32'),세로:getByte('hunit32')} // 개체의 가로, 세로 크기.
                ,절대위치:{x:getByte('hunit32'),y:getByte('hunit32')} // 틀 원점부터 개체 위치 x, y.
                ,차지영역:{x:getByte('shunit32')  // 선 두께 등을 고려하여 개체가 차지하는 영역을 x, y, xsize, 
                          ,y:getByte('shunit32')  // ysize 순서로 나타냄. 좌표는 개체의 원점부터 상대적인 값.
                          ,xsize:getByte('shunit32')
                          ,ysize:getByte('shunit32')}
                ,기본속성:그리기개체기본속성()
                ,회전속성:null
                ,그라데이션속성:null
                ,비트맵패턴속성:null
            }
            if(info.기본속성.기타옵션 & 0x10000) info.그라데이션속성 = 그리기개체그라데이션속성();
            if(info.기본속성.기타옵션 & 0x20000) info.회전속성 = 그리기개체회전속성();
            if(info.기본속성.기타옵션 & 0x40000) info.비트맵패턴속성 = 그리기개체비트맵패턴속성();
            return info;
        }
        function 선세부정보(){
            return {
                 정보1의길이:getByte('dword')  // 4
                ,선의모양정보:getByte('dword') // bit 0 = horizontal flip
                                               // bit 1 = vertical flip
                ,정보2의길이:getByte('dword')  // 0
            }
        }
        function 글상자세부정보(){
            return {
                 정보1의길이:getByte('dword')  // 0
                ,정보2의길이:getByte('dword')  // 문단리스트 내용의 길이 n
                ,문단리스트의내용:null // 글상자 내부의 문단 리스트를 ㅏ이너리 스트림으로 표현
            }
        }

        function 예약특수문자형식(식별코드){ // 8 + n Byte
            if(식별코드>31) return null;
            if(식별코드==13) return null;
            console.log('식별코드',식별코드)
            /*
            var info={특수문자코드1:getByte('hchar')
                     ,정보길이     :getByte('dword') // n
                     ,특수문자코드2:getByte(2,'int16') //getByte('hchar')
                     ,정보         :[]}
            info.정보 = getByteArray('byte',info.정보길이);
            */
            var info={특수문자코드1:식별코드
                     ,정보길이     :getByte('dword') // n
                     ,특수문자코드2:getByte(2,'int16') //getByte('hchar')
                     ,정보         :[]}
            //info.정보 = getByteArray('byte',info.정보길이);
            switch(식별코드){
                case  5 : info.정보 = {    // 필드 코드 - info.정보길이:예약
                            
                            }
                            break;
                case  9 : info.정보 = {    // 탭 - info.정보길이:탭문자폭,점끌기여부로 파싱
                                 탭문자폭  :info.정보길이     & 0xffff  // 1/1800인치
                                ,점끌기여부:info.정보길이>>16 & 0xffff  // 
                            }
                            break;
                case 10 : info.정보 = {    // 표/텍스트박스/수식/버튼/하이퍼텍스트 - info.정보길이:예약
                                 예약1:getByteArray('byte',8)
                                ,기준위치:['0:글자', '1:문단', '2:페이지', '3:종이'][getByte('byte')]
                                ,그림피함:['0:자리차지', '1:투명', '2:어울림'][getByte('byte')]
                                ,가로위치:getByte('shunit')  // -1=왼쪽, -2=오른쪽, -3=가운데, 이외=임의
                                ,세로위치:getByte('shunit')  // -1=위, -2=아래, -3=가운데, 이외=임의
                                ,기타옵션:getByte('word')    // bit 0 - 1 = 예약
                                                             // bit 2 = 수식 크기를 문단 폭에 맞출지 여부
                                                             // bit 3 = 예약
                                                             // bit 4 = [하이퍼텍스트]인지 여부
                                                             // bit 5 - 15 = 예약
                                ,특수문자코드:getByte('hchar') // 늘 10 이다
                                ,여백:[[getByte('shunit'),getByte('shunit'),getByte('shunit'),getByte('shunit')]   // [0-2][] = 바깥/안/셀 여백
                                      ,[getByte('shunit'),getByte('shunit'),getByte('shunit'),getByte('shunit')]   // [][0-3] = 왼쪽/오른쪽/위/아래 여백
                                      ,[getByte('shunit'),getByte('shunit'),getByte('shunit'),getByte('shunit')]]  // ※ [1][3] = 안여백-아래여백
                                //,박스크기:getByteArray('hunit',2) // 가로, 세로
                                ,박스크기:getByte('hunit',2) // 가로, 세로
                                ,캡션크기:getByteArray('hunit',3) // 가로, 세로, 길이
                                //,전체크기:getByteArray('hunit',2) // 박스 크기 + 캡션 + 여백
                                ,전체크기:getByte('hunit',2) // 박스 크기 + 캡션 + 여백
                                ,예약2:getByteArray('byte',4)
                                ,줄간격보호:['0:보호하지않음','1:보호함'][getByte('byte')]
                                ,예약3:getByte('byte')
                                ,박스위치:getByteArray('hunit',2) // 실제 계산된 결과 박스의 위치. 가로, 세로.
                                ,예약4:getByteArray('byte',4)
                                ,캡션위치:getByte('word') // 0 - 7, 메뉴 순서
                                ,박스번호:getByte('word') // 0부터 시작해 순서대로 매긴 일련 번호
                                ,예약5:getByteArray('byte',2)
                                ,표ID:getByte('word')  // 차트 연결 표 식별ID/BaseLine:수식일때. (1800 DPI)
                                ,박스종류:['0=표', '1=텍스트박스', '2=수식', '3=버튼'][getByte('word')]
                                ,셀개수:getByte('word') // 표일 때는 셀의 개수, 이외는 늘 1이다. (수식도 1)
                                ,보호:getByte('word') 
                            }
                            break;
                case 11 : info.정보 = {    // 그림 - info.정보길이:예약
                                 추가정보길이:getByte('dword') // n
                                ,예약1:getByteArray('byte',4)
                                ,기준위치:['0:글자', '1:문단', '2:페이지', '3:종이'][getByte('byte')]
                                ,그림위치:['0:자리차지', '1:투명', '2:어울림'][getByte('byte')]
                                ,가로위치:getByte('shunit')  // -1=왼쪽, -2=오른쪽, -3=가운데, 이외=임의
                                ,세로위치:getByte('shunit')  // -1=위, -2=아래, -3=가운데, 이외=임의
                                ,기타옵션:getByte('word')    // bit 0 = 테두리 그릴지 여부
                                                             // bit 1 = 그림을 반전시킬지 여부. 0이면 반전.
                                                             // bit 2 = Fit to column
                                                             // bit 3 = 0x8  unknown file
                                                             // bit 4 = 0x10 [hypertext]
                                                             // bit 5 = 0x20 unkown size
                                ,특수문자코드:getByte('hchar') // 늘 11 이다
                                ,여백:[[getByte('shunit'),getByte('shunit'),getByte('shunit'),getByte('shunit')]   // [0-2][] = 바깥/안/셀 여백
                                      ,[getByte('shunit'),getByte('shunit'),getByte('shunit'),getByte('shunit')]   // [][0-3] = 왼쪽/오른쪽/위/아래 여백
                                      ,[getByte('shunit'),getByte('shunit'),getByte('shunit'),getByte('shunit')]]  // ※ [1][2] = 안여백-아래여백
                                                                                                                   // ※ 그림에서 셀 여백은 사용되지 않음
                                ,박스크기:getByteArray('hunit',2) // 가로, 세로
                                ,캡션크기:getByteArray('hunit',3) // 가로, 세로, 길이
                                ,전체크기:getByteArray('hunit',2) // 박스 크기 + 캡션 + 여백
                                ,예약2:getByteArray('byte',4)
                                ,줄간격보호:['0:보호하지않음','1:보호함'][getByte('byte')]
                                ,예약3:getByte('byte')
                                ,박스위치:getByteArray('hunit',2) // 실제 계산된 결과 박스의 위치. 가로, 세로.
                                ,예약4:getByteArray('byte',4)
                                ,캡션위치:getByte('word') // 0 - 7, 메뉴 순서
                                ,박스번호:getByte('word') // 0부터 시작해 순서대로 매긴 일련 번호
                                ,그림종류:['0:외부 파일', '1:OLE Object', '2:Embedded Image', '3:Drawing Object'][getByte('byte')]
                                ,건너뜀:getByteArray('hunit',2) // 그림에서 실제 표시를 시작할 위치 (가로, 세로)
                                ,확대비율:getByteArray('word',2) // 0 = 고정, 이외 = 퍼센트 단위 비율 (가로, 세로)
                                //,그림파일이름:null // 그림 종류가 0, 1, 2일 때만 사용됨.
                                ,그림파일이름:getByte('hchar',128).join('') // 그림 종류가 0, 1, 2일 때만 사용됨.
                                ,밝기:getByte('byte') // 워터마크: 그림의 밝기 (-100 - 100)
                                ,명암: getByte('byte') // 워터마크: 그림의 명암 (-100 - 100)
                                ,그림효과:['0:원래 그림으로', '1:그레이 스케일', '2:흑백으로'][getByte('byte')]
                                ,보호여부:getByte('byte') // 그림보호가 되어 있는 지의 여부
                                ,예약5:getByteArray('byte',5)
                                ,추가정보:null // 그림 종류가 3(Drawing Object)일 때만 사용됨.
                                               // 그 외는 하이퍼텍스트 정보 (11.1 참고)
                            }
                          if(info.정보.그림종류=='3:Drawing Object'){
                              //info.정보.추가정보 = getByteArray('byte',info.정보.추가정보길이);
                              //info.정보.보정 = getByteArray('byte',19+28);
                              //info.정보.보정 = getByteArray('byte',47); // 이게 왜 필요한걸까??????
                              //미완 /그리기 개체 자료 구조/ 필요
/*
글에 내장된 그림 그리기 기능으로 그려진 개체(그림 종류 3)일 때는 실제 데이터는 추가 정보에 
저장된다. 자세한 것은 ‘그리기 개체 자료 구조’를 참조하기 바란다.
그리기 개체가 아닐 때는 하이퍼 텍스트 정보가 포함되어 있다. 추가 정보 내용 중 처음 4byte(dword)를 
읽어서 그 값이 0x269이면 하이퍼 텍스트 정보인 것으로 간주한다.
*/
                              //var 틀헤더=틀헤더정보();
                              //console.debug('틀헤더',틀헤더)
                              //var 그리기개체공통헤더 = 그리기개체공통헤더정보();
                              //console.debug('그리기개체공통헤더',그리기개체공통헤더)
                              info.정보.추가정보 = {
                                   틀헤더:틀헤더정보()
                                  ,그리기개체공통헤더:그리기개체공통헤더정보()
                                  //,선세부정보:선세부정보()
                                  ,글상자세부정보:글상자세부정보()
                              }
//                              info.정보.보정 = getByteArray('byte',27); // 이게 왜 필요한걸까??
                              //info.정보.보정 = getByteArray('byte',27+28);
                              //info.정보.보정 = getByteArray('byte',55);
//                              info.정보.보정 = getByteArray('byte',47);
//                              info.정보.보정 = getByteArray('byte',278);
                          }
                          //info.정보.보정 = getByteArray('byte',23);
                          //info.정보.보정 = getByteArray('byte',19);

                            break;
                case 14 : info.정보 = {    // 선, 정보=선정보 - info.정보길이:예약
                                 예약1:getByteArray('byte',8)
                                ,기준위치:['0:글자','1:문단','2:페이지','3:종이'][getByte('byte')]
                                ,그림피함:getByte('byte') // 늘 1 이다
                                ,가로위치:getByte('hunit') // 선을 대각선으로 하는 사각형의 시작점 x좌표
                                ,세로위치:getByte('hunit') // 선을 대각선으로 하는 사각형의 시작점 y좌표
                                ,예약2:getByteArray('byte',2)
                                ,특수문자코드:getByte('hchar') // 늘 14 이다
                                ,예약3:getByteArray('byte',24)
                                ,박스크기:getByteArray('hunit',2) // 선을 대각선으로 하는 사각형의 가로,세로 크기
                                ,예약4:getByteArray('byte',14)
                                ,줄간격보호:['0:보호하지않음','1:보호함'][getByte('byte')]
                                ,예약5:getByteArray('byte',9)
                                ,선위치:getByteArray('hunit',4) // (시작점 x,y) (끝점 x,y) 좌표
                                ,선굵기:getByte('hunit')
                                ,음영비율:getByte('word')
                                ,색깔:getByte('word')
                            }
                            break;
                case 15 : info.정보 = null // 숨은설명 - info.정보길이:예약
                            break;
                case 16 : info.정보 = {    // 머리말/꼬리말 - info.정보길이:예약
                                 예약:getByteArray('byte',8)
        //                        ,구분:getByte('byte') // 0:머리말 1:꼬리말
        //                        ,종류:getByte('byte') // 0:양쪽면 1:짝수면 2:홀수면
                                ,구분:['0:머리말', '1:꼬리말'][getByte('byte')]
                                ,종류:['0:양쪽면', '1:짝수면', '2:홀수면'][getByte('byte')]
                            }
                            break;
                case 20 : info.정보 = { // 쪽번호달기 - info.정보길이:위치,모양으로 파싱
                                 위치:info.정보길이     & 0xffff  // 0-8
                                ,모양:info.정보길이>>16 & 0xffff  // 0 = arabic, 1 = capital roman, 2 = small roman
                                                                 // 3-5 = 0-2와 같은 모양에 ‘- ## -’ 형태로 출력
                            }
                            break;
            }
            return info;
        }

        var readError = false;
        var line = 0;
        var MAXLINE = 5;
        DEBUG = false;
        GetByte.debug=DEBUG;
        var depth=0;
        function 문단읽기(toNext){
 //           console.group('문단읽기')
            var tmp='';
            line++;
            if(GetByte.pos>GetByte.uInt8Array.length){
                console.log('문서읽기 오류 : OFFSET 초과');
                readError= true; // offset 초과시 강제종료
                return tmp;
            }
            /*
            if(line==MAXLINE-3) DEBUD=true;;
            if(DEBUG) if(line==MAXLINE){
                console.debug('디버깅중-강제종료함');
                return tmp;
            }
            */

            //if(DEBUG)
                console.debug('>>>>>>line', line, 'depth', depth);
            var 문단 = 문단정보();
            HWP.문단 = 문단;
            if(DEBUG) console.log('문단',문단);
            if(DEBUG) console.log('pos', GetByte.pos, GetByte.uInt8Array.length)
            if(DEBUG) if(문단.글자수) console.log('문단.특수문자플래그',문단.특수문자플래그);


            if(문단.글자수==0){ // 문단리스트의 끝
//                console.groupEnd();
                depth--;
                return tmp;
            }

            //if(문단.앞문단모양==0 && 문단.글자수!=0){
            //    앞문단=문단;
            //    depth++;
            //}else{
            //    //문단.특수문자플래그 = 앞문단.특수문자플래그;
            //}
            //if(DEBUG) console.log('depth',depth)

            var 줄 = [];
            for(var i=0; i<문단.줄수; i++) 줄.push( 줄정보() );
            if(DEBUG) console.log('줄',줄);
            HWP.줄 = 줄;
            if(DEBUG) console.log('pos', GetByte.pos, GetByte.uInt8Array.length)
            if(문단.글자모양포함){
                var 글자모양=글자모양정보(문단.글자수);
                HWP.글자모양 = 글자모양;
                if(DEBUG) console.log('글자모양',글자모양);
                if(DEBUG) console.log('pos', GetByte.pos, GetByte.uInt8Array.length)
            }


            if(문단.특수문자플래그){
                for(var i=0; i<문단.글자수; i++){
                    if(GetByte.pos>GetByte.uInt8Array.length){
                        console.log('문서읽기 오류 : OFFSET 초과');
                        return tmp; // offset 초과시 강제종료
                    }
                    var 식별코드 = GetByte.getPos();
                    var ch = getByte('hchar');
//                    if(식별코드=='5') str +=  '[[[[[식별코드5]]]]]]';
//                    if(ch=='8') str +=  '[[[[[식별코드8]]]]]]'; //??
                    if(DEBUG)
                        console.log(`ch[${ch}]`, 식별코드, GetByte.pos);
                    if(식별코드==13) { // 문단종료
                        depth++;
                        tmp +=  '\n'+문단읽기(0);
                        return tmp;
                    }
                    if(식별코드!=12 && 식별코드>4 && 식별코드<32){
                        var 특수문자 = 예약특수문자형식(식별코드);
                        //if(DEBUG)
                            console.info('특수문자', 특수문자);
                        if(DEBUG) console.log('pos', GetByte.pos, GetByte.uInt8Array.length)
//                        if(ch=='13') str+='\n';
                        if(식별코드== 9) tmp+='\t';
                        if(식별코드==10){
                            console.group('식별코드10처리')
                            tmp+='[표/텍스트박스/수식/버튼/하이퍼텍스트]:\n';
                            for(var j=0; j<특수문자.정보.셀개수;j++){
                                var 셀=셀정보();
                                console.debug(`셀[${j}]`, 셀);
                                //tmp+=`[셀{${i}}]:`;
                            }
                            for(var j=0; j<특수문자.정보.셀개수;j++){
                                //console.debug(`셀[${j}]콜`);
                                depth++;
                                tmp+=`[셀{${j}}]:`+문단읽기(1);
                                //console.debug(`셀[${j}]종료`);
                            }
                            //console.debug('표/텍스트박스/수식/버튼/하이퍼텍스트 종료')
                            console.groupEnd();
                            //console.group('캡션문단')
                            //tmp+문단읽기(depth+1); // 캡션문단읽기
                            //console.groupEnd();
                        }
                        if(식별코드==11) tmp+='[그림]'
                        if(식별코드==16) tmp+='['+특수문자.정보.구분+']:'
                        //if(문단.앞문단모양==0) 
//                        if(ch==14) getByteArray('hchar',40);
                        if(식별코드==10 || 식별코드==11 || 식별코드==15 || 식별코드==16 || 식별코드==17){
//                        if(식별코드==11 || 식별코드==15 || 식별코드==16 || 식별코드==17)
                            console.group('캡션문단??')
                            depth++;
                            tmp+=문단읽기(1);
                            console.groupEnd();
                        }
                    }else{
                        tmp+=ch;
                        //if(ch=='\n') break;
                    }
                }
            }else{
                if(DEBUG) GetByte.debug = false;
                GetByte.isHwp = true; // HWPChar 적용시작
                tmp += getByte(문단.글자수*2);
                if(DEBUG) console.log('tmp',tmp)
                GetByte.isHwp = false; // HWPChar 적용해제
                if(DEBUG) GetByte.debug = true;
            }
            if(DEBUG) console.log('pos', GetByte.pos, GetByte.uInt8Array.length)
            //str += tmp;
//            console.groupEnd();
//console.log('[[[[[[[[[toNext]]]]]]]',toNext);
//            return tmp+문단읽기(toNext);
//            return tmp;
if(toNext!=0)   return tmp+문단읽기();
else            return tmp;
        }

        var str_header = '[HWP Document File V' + headerString.version+'] 문서';
        var str = '';
        str += 문단읽기(0);
        /**/
        // 5000 문단(라인)이 넘어가면 스택오버플로 이슈로 재귀호출에서 반복호출로 변경함.
        // RangeError: Maximum call stack size exceeded
        while(1){ 
            if(HWP.문단.글자수==0){ // 문단리스트의 끝
//            if(depth==0 && HWP.문단.글자수==0){ // 문단리스트의 끝
                console.log('depth',depth);
                break;
            }
            str += 문단읽기(0);
        }
        /**/
        if(GetByte.pos>=GetByte.uInt8Array.length){
            var 추가정보블록=추가정보();
    //        var 추가정보블록;
            if(DEBUG) console.info('추가정보블록',추가정보블록);
            HWP.추가정보블록 = 추가정보블록;
                if(DEBUG) console.log('pos', GetByte.pos, GetByte.uInt8Array.length)
        }

        //var _add = GetByte.pos==GetByte.uInt8Array.length?'읽기완료':'읽기오류'
        //_add += `(${GetByte.pos.format()}/${GetByte.uInt8Array.length.format()} Byte)`;
        var _add = `(${GetByte.pos.format()}/${GetByte.uInt8Array.length.format()} Byte)`;
//        var _add = !!추가정보블록?'완료':'오류'
//        var _add = readError?'오류':'완료'
        str_header+='/' +line.format()+'라인 ' +_add+ '\n\n'


        return str_header + str;
    }


Uint8Array.prototype.findArr = function(start,findArr){
    var isFind = false;
    var idx = -1;
    var jStart = 0;
    for(var i=start; i<this.length; i++){
        if(j == findArr.length){ isFind=true; break; }
        for(var j=0; j<findArr.length; j++){
            /*
            if(this[i] == findArr[j]) {
                idx = i;
                jStart++;
                break;
            }
            */
            if(this[i+j] != findArr[j]) break;

        }
    }
    if(isFind) idx = i-findArr.length+1;
    return idx;
}


    var hwpFiles = [
    /* 0 */  "dos/C_Drv/COMM/I53/DOWN/프린세~2.HWP"  // v3.00
    /* 1 */ ,"DOS/C_Drv/COMM/I60/DOWN/DOWNBACK/PBRI0010.HWP" // v3.00
    /* 2 */ ,"DOS/C_Drv/LANG/TC/README.HWP"
    /* 3 */ ,"dos/C_Drv/LANG/TC/TURBOLIB.HWP"
    /* 4 */ ,"DOS/C_Drv/MUSIC/DATA/OCP/OCPLAY.HWP"
    /* 5 */ ,"dos/C_Drv/MUSIC/DATA/OCP/UPDATE.HWP"
    /* 6 */ ,"DOS/C_Drv/MUSIC/MIDI/CAKEPRO/DOWN/요금.HWP"  // v3.00
    /* 7 */ ,"dos/C_Drv/OFFICE/HWP30/PATCH/README.HWP"     // v3.00 (안됨)
    /* 8 */ ,"DOS/C_Drv/이야기방/새글/엽기적인그녀/엽기적인그녀 2부.hwp" // v3.00
    /* 9 */ ,"txt/책 ebook 전자책/환타지/하이엘프의숲/FOREST0.HWP" // v3.00
    /*10 */ ,"한글문서파일형식_배포용문서_revision1.2.hwp" // v3.00
        ];

//    url = 'load.php?file=' + encodeURIComponent(url||hwpFiles[8]);
//    url = 'load.php?file=DOS/C_Drv/COMM/I60/DOWN/DOWNBACK/PBRI0010.HWP';
//    url = 'load.php?file=DOS/C_Drv/LANG/TC/README.HWP';
//    url = 'load.php?file=DOS/C_Drv/MUSIC/DATA/OCP/OCPLAY.HWP';
//    url = 'load.php?file=DOS/C_Drv/MUSIC/MIDI/CAKEPRO/DOWN/요금.HWP';
    url = 'load.php?file=' + (url||'DOS/C_Drv/MUSIC/DATA/OCP/OCPLAY.HWP');

console.log('url',url)
    fetch(url)
        .then(rs=>{return rs.arrayBuffer();})
        .then(buffer => hwp.innerText=HWP(buffer))
  </script>
</head>
<body>
<div id=listDiv><pre role="img" aria-label="ASCII COW" id=hwp>&nbsp;</pre></div>
<div id=pageDiv></div>
<div id=debug></div>
</body>
</html>
